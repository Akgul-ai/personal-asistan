Harika bir proje! İkinci aşama olan temel sistem geliştirme ve API entegrasyonunu Java tabanlı bir web uygulaması olarak nasıl yapılandırabileceğimize dair bir yol haritası ve kod iskeleti sunalım. Burada Spring Boot kullanacağız çünkü modern Java web uygulamaları için popüler, hızlı geliştirme imkanı sunan ve REST API oluşturmayı kolaylaştıran bir framework'tür.

Proje Yapısı (Maven Örneği):

assistant-backend/
├── pom.xml             // Proje bağımlılıkları ve build ayarları
└── src/
    └── main/
        ├── java/
        │   └── com/
        │       └── yourcompany/
        │           └── assistant/
        │               ├── AssistantApplication.java  // Spring Boot Başlangıç Noktası
        │               ├── config/
        │               │   ├── SecurityConfig.java     // Spring Security Ayarları
        │               │   └── AppConfig.java        // Genel Uygulama Ayarları (API Key vb.)
        │               ├── controller/
        │               │   ├── AuthController.java     // Kimlik Doğrulama Endpoint'leri (/login, /register)
        │               │   └── AssistantController.java// Asistan Komutları Endpoint'leri (/api/assistant/...)
        │               ├── dto/                      // Data Transfer Objects (İstek/Yanıt nesneleri)
        │               │   ├── UserDto.java
        │               │   ├── WeatherDto.java
        │               │   ├── NewsDto.java
        │               │   └── CommandDto.java
        │               ├── model/                      // Veritabanı Varlıkları (Eğer JPA kullanılıyorsa)
        │               │   └── User.java
        │               ├── repository/                 // Veritabanı Erişim Katmanı (Eğer JPA kullanılıyorsa)
        │               │   └── UserRepository.java
        │               ├── security/
        │               │   ├── JwtTokenProvider.java   // JWT oluşturma/doğrulama (Eğer JWT kullanılıyorsa)
        │               │   └── UserDetailsServiceImpl.java // Spring Security için kullanıcı detayları servisi
        │               └── service/
        │                   ├── AuthService.java        // Kimlik doğrulama iş mantığı
        │                   ├── WeatherService.java     // Hava Durumu API entegrasyonu
        │                   ├── NewsService.java        // Haber API entegrasyonu
        │                   ├── CalendarService.java    // Google Calendar API entegrasyonu
        │                   ├── NlpService.java         // Temel NLP işlemleri
        │                   └── CommandProcessingService.java // Gelen komutları işleme ve yönlendirme
        └── resources/
            ├── application.properties  // Uygulama ayarları (veritabanı, API key'ler vb.)
            ├── static/                 // Statik dosyalar (CSS, JS, Resimler - Eğer basit bir UI varsa)
            └── templates/              // HTML şablonları (Eğer Thymeleaf gibi bir şablon motoru kullanılıyorsa)


1. Gerekli Bağımlılıklar (pom.xml)

<dependencies>
    <!-- Spring Boot Web (REST API için temel) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Spring Boot Security (Kimlik Doğrulama ve Yetkilendirme) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>

    <!-- JWT Desteği (Eğer token tabanlı kimlik doğrulama kullanacaksanız) -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.11.5</version> <!-- Güncel sürümü kontrol edin -->
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>0.11.5</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
        <version>0.11.5</version>
        <scope>runtime</scope>
    </dependency>

    <!-- Veritabanı Erişimi (İsteğe Bağlı - Kullanıcıları saklamak için) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId> <!-- Veya PostgreSQL, MySQL vb. -->
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>

    <!-- Google API Client (Google Calendar için) -->
    <dependency>
        <groupId>com.google.api-client</groupId>
        <artifactId>google-api-client</artifactId>
        <version>2.0.0</version> <!-- Güncel sürümü kontrol edin -->
    </dependency>
    <dependency>
        <groupId>com.google.oauth-client</groupId>
        <artifactId>google-oauth-client-jetty</artifactId>
        <version>1.34.1</version> <!-- Güncel sürümü kontrol edin -->
    </dependency>
    <dependency>
        <groupId>com.google.apis</groupId>
        <artifactId>google-api-services-calendar</artifactId>
        <version>v3-rev20220715-2.0.0</version> <!-- Güncel sürümü kontrol edin -->
    </dependency>

    <!-- Temel NLP için (Örnek: Apache OpenNLP) -->
    <dependency>
        <groupId>org.apache.opennlp</groupId>
        <artifactId>opennlp-tools</artifactId>
        <version>2.3.1</version> <!-- Güncel sürümü kontrol edin -->
    </dependency>


    <!-- Lombok (Boilerplate kodu azaltmak için - isteğe bağlı) -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>

    <!-- Spring Boot Test (Birim ve entegrasyon testleri için) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Xml
IGNORE_WHEN_COPYING_END

2. Kod Örnekleri (İskelet)

AssistantApplication.java

package com.yourcompany.assistant;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AssistantApplication {

    public static void main(String[] args) {
        SpringApplication.run(AssistantApplication.class, args);
    }

}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Java
IGNORE_WHEN_COPYING_END

SecurityConfig.java (Basit Örnek)

package com.yourcompany.assistant.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
// JWT kullanılıyorsa ilgili filtreleri ve UserDetailsService'i eklemeniz gerekir.

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // API için genellikle devre dışı bırakılır
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/auth/**").permitAll() // Login/Register herkese açık
                .requestMatchers("/api/assistant/**").authenticated() // Asistan endpoint'leri kimlik doğrulaması gerektirir
                .anyRequest().permitAll() // Diğer her şey (varsa) herkese açık (veya kısıtlayın)
            )
            // JWT kullanıyorsanız:
            // .sessionManagement(sess -> sess.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            // .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class) // JWT filtrenizi ekleyin
            .httpBasic(withDefaults -> {}); // Veya formLogin() veya JWT için kendi ayarlarınız

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // TODO: UserDetailsService bean'ini implemente edin (UserDetailsServiceImpl)
    // TODO: AuthenticationManager bean'ini expose edin (gerekirse)
    // TODO: JWT filtresi bean'ini implemente edin (gerekirse)
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Java
IGNORE_WHEN_COPYING_END

AssistantController.java

package com.yourcompany.assistant.controller;

import com.yourcompany.assistant.dto.CommandDto;
import com.yourcompany.assistant.service.CommandProcessingService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/assistant")
public class AssistantController {

    @Autowired
    private CommandProcessingService commandProcessingService;

    // Yazılı komut endpoint'i
    @PostMapping("/command")
    public ResponseEntity<String> processTextCommand(@RequestBody CommandDto commandDto) {
        // TODO: Güvenlik katmanından giriş yapan kullanıcı bilgisini al (Principal)
        // Örnek: Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        // String currentPrincipalName = authentication.getName();

        try {
            String response = commandProcessingService.processCommand(commandDto.getCommandText());
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            // TODO: Daha detaylı hata yönetimi
            return ResponseEntity.badRequest().body("Komut işlenirken bir hata oluştu: " + e.getMessage());
        }
    }

    // Sesli komut endpoint'i (Frontend'den text olarak gelir varsayımı)
    // Gerçek ses işleme frontend'de veya ayrı bir serviste yapılabilir.
    // Eğer backend'e ses dosyası geliyorsa, farklı bir işlem gerekir.
    @PostMapping("/voice-command")
    public ResponseEntity<String> processVoiceCommand(@RequestBody CommandDto commandDto) {
         // Genellikle ses yazıya çevrildikten sonra bu endpoint çağrılır.
         // Bu yüzden text command ile aynı mantık işleyebilir.
         return processTextCommand(commandDto);
    }

    // --- Direkt API endpointleri (Alternatif veya test için) ---

    @GetMapping("/weather")
    public ResponseEntity<?> getWeather(@RequestParam String location) {
        try {
            // Direkt WeatherService'i çağırabilirsiniz
             // Object weatherData = weatherService.getWeatherByLocation(location);
             // return ResponseEntity.ok(weatherData);
             return ResponseEntity.ok("Hava durumu verisi burada olacak: " + location); // Örnek
        } catch (Exception e) {
            return ResponseEntity.badRequest().body("Hava durumu alınamadı: " + e.getMessage());
        }
    }

     @GetMapping("/news")
    public ResponseEntity<?> getNews(@RequestParam(required = false) String topic) {
        try {
            // Direkt NewsService'i çağırabilirsiniz
            // List<NewsArticleDto> news = newsService.getLatestNews(topic);
            // return ResponseEntity.ok(news);
            return ResponseEntity.ok("Haberler burada olacak. Konu: " + (topic != null ? topic : "Genel")); // Örnek
        } catch (Exception e) {
            return ResponseEntity.badRequest().body("Haberler alınamadı: " + e.getMessage());
        }
    }

    // TODO: Google Calendar endpoint'leri (OAuth akışını gerektirir)
    // Örnek: /calendar/events, /calendar/add-event
    // Bunlar kullanıcıya özel olmalı ve kullanıcının yetkilendirmesini gerektirir.

}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Java
IGNORE_WHEN_COPYING_END

CommandProcessingService.java

package com.yourcompany.assistant.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class CommandProcessingService {

    @Autowired
    private NlpService nlpService;

    @Autowired
    private WeatherService weatherService;

    @Autowired
    private NewsService newsService;

    @Autowired
    private CalendarService calendarService; // Kullanıcıya özel token ile çağrılmalı

    public String processCommand(String commandText) throws Exception {
        // 1. NLP ile komutu analiz et (Basit keyword veya daha gelişmiş)
        String intent = nlpService.detectIntent(commandText); // Örnek: "get_weather", "get_news", "show_calendar"
        String location = nlpService.extractLocation(commandText); // Örnek: "İstanbul", "Ankara"
        String topic = nlpService.extractTopic(commandText); // Örnek: "teknoloji", "spor"
        // ... diğer parametreler (tarih, etkinlik adı vb.)

        // 2. Anlamlandırılan komuta göre ilgili servisi çağır
        switch (intent) {
            case "get_weather":
                if (location != null) {
                    // TODO: WeatherService'den hava durumunu al ve formatla
                    // WeatherDto weather = weatherService.getWeatherByLocation(location);
                    // return formatWeatherResponse(weather);
                    return location + " için hava durumu bilgisi getiriliyor...";
                } else {
                    return "Hangi konumun hava durumunu öğrenmek istiyorsunuz?";
                }
            case "get_news":
                // TODO: NewsService'den haberleri al ve formatla
                // List<NewsDto> news = newsService.getLatestNews(topic); // topic null olabilir
                // return formatNewsResponse(news);
                 return (topic != null ? topic + " hakkında" : "Genel") + " haberler getiriliyor...";
            case "show_calendar":
                 // TODO: CalendarService'den takvim etkinliklerini al (Kullanıcı kimliği ve token gerektirir)
                 // Bu kısım daha karmaşık olacak (OAuth)
                 // List<EventDto> events = calendarService.getUpcomingEvents(userId, userCredentials);
                 // return formatCalendarResponse(events);
                 return "Takvim etkinlikleri getiriliyor (Yetkilendirme Gerekli)...";
            // TODO: Diğer komutlar (add_event, vs.)
            default:
                return "Üzgünüm, bu komutu anlayamadım.";
        }
    }

    // --- Yanıt Formatlama Metotları ---
    // private String formatWeatherResponse(WeatherDto weather) { ... }
    // private String formatNewsResponse(List<NewsDto> news) { ... }
    // private String formatCalendarResponse(List<EventDto> events) { ... }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Java
IGNORE_WHEN_COPYING_END

NlpService.java (Çok Basit Örnek)

package com.yourcompany.assistant.service;

import org.springframework.stereotype.Service;
import java.util.Locale;

// Not: Bu çok temel bir örnektir. Gerçek NLP için OpenNLP, Stanford CoreNLP
// veya harici bir NLP servisi kullanmak daha iyi sonuç verir.
@Service
public class NlpService {

    // Basit Anahtar Kelime Tabanlı Anlamlandırma
    public String detectIntent(String text) {
        String lowerText = text.toLowerCase(new Locale("tr", "TR")); // Türkçe karakter desteği
        if (lowerText.contains("hava durumu") || lowerText.contains("hava nasıl")) {
            return "get_weather";
        } else if (lowerText.contains("haber") || lowerText.contains("haberler")) {
            return "get_news";
        } else if (lowerText.contains("takvim") || lowerText.contains("programım") || lowerText.contains("etkinlikler")) {
            return "show_calendar";
        }
        // TODO: Diğer niyetleri ekle
        return "unknown";
    }

    // Basit Yer İsimlerini Çıkarma (Çok kaba)
    public String extractLocation(String text) {
        String lowerText = text.toLowerCase(new Locale("tr", "TR"));
        // Örnek: "İstanbul hava durumu", "Ankara'da hava nasıl?"
        // Gerçek uygulamada Named Entity Recognition (NER) kullanılmalı
        if (lowerText.contains("istanbul")) return "İstanbul";
        if (lowerText.contains("ankara")) return "Ankara";
        if (lowerText.contains("izmir")) return "İzmir";
        // ... diğer şehirler
        return null; // Bulunamadı
    }

     // Basit Konu Çıkarma (Çok kaba)
     public String extractTopic(String text) {
        String lowerText = text.toLowerCase(new Locale("tr", "TR"));
         if (lowerText.contains("teknoloji")) return "technology"; // NewsAPI için
         if (lowerText.contains("spor")) return "sports";
         if (lowerText.contains("sağlık")) return "health";
        // ... diğer konular
        return null; // Genel haberler için null dönebilir
     }

     // TODO: Apache OpenNLP veya Stanford CoreNLP kullanarak daha gelişmiş
     //       Intent Detection ve Named Entity Recognition (NER) implementasyonu.
     //       Bu kütüphanelerin model dosyalarını yüklemeniz ve kullanmanız gerekir.
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Java
IGNORE_WHEN_COPYING_END

WeatherService.java, NewsService.java, CalendarService.java

Bu servisler ilgili API'lere HTTP istekleri yapmak için Spring'in RestTemplate veya WebClient'ını kullanır.

API Key'leri application.properties dosyasından @Value anotasyonu ile alırlar.

API'lerden dönen JSON yanıtlarını dto paketindeki ilgili DTO (Data Transfer Object) sınıflarına map ederler (Jackson kütüphanesi otomatik yapar).

CalendarService özellikle Google OAuth 2.0 akışını yönetmeli ve kullanıcıya özel erişim/yenileme token'larını güvenli bir şekilde saklamalıdır (örneğin veritabanında kullanıcıyla ilişkilendirerek). Bu kısım diğerlerine göre daha karmaşıktır.

application.properties

# Server Port
server.port=8080

# --- API Keys (Güvenli bir yerden alınmalı, örn: Environment Variables) ---
api.openweathermap.key=YOUR_OPENWEATHERMAP_API_KEY
api.newsapi.key=YOUR_NEWSAPI_KEY

# --- Google Cloud Credentials (OAuth 2.0) ---
# Genellikle credentials.json dosyası olarak indirilir ve classpath'e konur.
# Veya Client ID ve Secret olarak buraya eklenebilir (daha az güvenli).
google.credentials.location=classpath:credentials.json # Örnek dosya yolu

# --- JWT Settings (Eğer JWT Kullanılıyorsa) ---
# jwt.secret=YourSuperSecretKeyWhichIsLongAndSecure
# jwt.expiration.ms=86400000 # 24 saat

# --- Database Settings (Eğer JPA Kullanılıyorsa - H2 Örneği) ---
# spring.datasource.url=jdbc:h2:mem:assistantdb
# spring.datasource.driverClassName=org.h2.Driver
# spring.datasource.username=sa
# spring.datasource.password=password
# spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
# spring.jpa.hibernate.ddl-auto=update # Geliştirme için 'update' veya 'create', prod için 'validate' veya 'none'
# spring.h2.console.enabled=true # H2 veritabanı konsolunu aktif et (geliştirme için)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Properties
IGNORE_WHEN_COPYING_END

Frontend (Web Sayfası):

Bu backend API'sini kullanacak bir web sayfası (frontend) ayrıca geliştirilmelidir. Bu genellikle HTML, CSS ve JavaScript (React, Angular, Vue veya vanilla JS) kullanılarak yapılır.

Kullanıcı Arayüzü: Kullanıcının komutları yazabileceği bir metin alanı ve/veya sesli komut için bir mikrofon butonu içerir.

API Çağrıları: JavaScript (fetch veya axios gibi kütüphanelerle), kullanıcının girdiği komutu veya sesli komutun metin karşılığını backend'deki /api/assistant/command veya /api/assistant/voice-command endpoint'ine POST isteği ile gönderir. Kimlik doğrulama gerekiyorsa (JWT kullanılıyorsa), isteğin Authorization header'ına token eklenir.

Yanıt Gösterimi: Backend'den dönen yanıtı alır ve kullanıcıya gösterir.

Ses İşleme (Frontend): Sesli komut için JavaScript'in Web Speech API'si kullanılabilir. Bu API, kullanıcının konuşmasını metne çevirir ve bu metin backend'e gönderilir.

Kimlik Doğrulama: Login/Register sayfaları oluşturulur ve bunlar backend'deki /auth/login, /auth/register endpoint'lerini çağırır. Başarılı login sonrası alınan token (eğer JWT ise) localStorage veya sessionStorage'da saklanıp sonraki isteklerde kullanılır.

Özet Çıktı:

Bu yapı ile oluşturulan Java backend uygulaması:

/auth/** endpoint'leri üzerinden kullanıcı kaydı ve girişi (kimlik doğrulama) yapabilir.

/api/assistant/** endpoint'leri üzerinden (kimlik doğrulaması yapıldıktan sonra) yazılı veya sesli (metne çevrilmiş) komutları alabilir.

CommandProcessingService ve NlpService aracılığıyla komutun ne anlama geldiğini (hava durumu, haber vs.) ve ilgili parametreleri (konum, konu) temel düzeyde anlayabilir.

İlgili servisi (WeatherService, NewsService, CalendarService) çağırarak harici API'lerden veriyi çekebilir.

Aldığı veriyi işleyip kullanıcıya anlamlı bir metin yanıtı olarak döndürebilir.

Bu iskelet, 2. Aşama hedeflerini karşılayan bir Java web uygulaması geliştirmek için sağlam bir temel oluşturur. Her bir servisin ve NLP kısmının detaylı implementasyonu gerekecektir.
